#!/usr/bin/env python3

################################################################################
#
# NAME
#
#        dtrsm-analyze-performance.py - analyzes performance data
#
# SYNOPSIS
#
#        dtrsm-analyze-performance.py < data
#
# DESCRIPTION
#
#        Analyzes the data generated by the dtrsm-performance.py script.
#
#        The result is a table that shows for each pair of (n, p) the
#        following information:
#
#        s (x/y:z)
#
#        where
#
#        s - The speedup of the FIXED mode over the REGULAR mode with
#            optimal parameters for both.
#        x - The optimal tile size for the REGULAR mode.
#        y - The optimal tile size for the FIXED mode.
#        z - The optimal size of the reserved set for the FIXED mode.
#
# EXAMPLE
#
#        The results/kebnekaise/dtrsm/data file was generated on the
#        Kebnekaise system at HPC2N. To run the analysis on this data,
#        run (from the top-level directory):
#
#        test/dtrsm/dtrsm-analyze-performance.py < results/kebnekaise/dtrsm/data
#
#        This will generate the following output:
#        
#                |              p= 7 |              p=14 |              p=21 |              p=28 | 
#        --------+-------------------+-------------------+-------------------+-------------------+
#        n= 2000 | 1.133 (100/190:2) | 1.499 ( 50/110:3) | 1.528 ( 80/ 70:3) | 1.540 ( 60/130:3) |
#        n= 4000 | 1.026 (180/360:2) | 1.206 ( 90/170:2) | 1.610 (100/160:3) | 1.620 (100/130:3) |
#        n= 6000 | 0.994 (280/280:1) | 1.094 (130/240:2) | 1.455 (110/230:3) | 1.625 (110/180:3) |
#        n= 8000 | 0.990 (390/410:1) | 1.043 (180/360:2) | 1.375 (130/300:3) | 1.477 (130/230:3) |
#        n=10000 | 0.994 (460/490:1) | 1.019 (220/380:2) | 1.287 (170/380:3) | 1.392 (130/280:3) |
#
#        The largest speedup (1.625) is observed for n = 6000 and p =
#        28. The optimal tile size for the REGULAR mode was 100, the
#        optimal tile size for the FIXED mode was 130 while reserving
#        3 cores.
#
# NOTE
#
#        Must be run from the directory containing the "test-dtrsm.x"
#        executable.
#
################################################################################

import sys

# Skip header line. 
sys.stdin.readline()

# Read records.
data = []
for line in sys.stdin:
    line = line.strip()
    fields = line.split()
    record = {'n' : int(fields[0]),
              'b' : int(fields[1]),
              'p' : int(fields[2]),
              'q' : int(fields[3]),
              'time' : float(fields[4]),
              'crit-path' : float(fields[5]),
              'long-path' : float(fields[6])}
    data.append(record)

# Find set of n.
n_set = set([r['n'] for r in data])

# Find set of p.
p_set = set([r['p'] for r in data])

# Create table.
table = []
for x in range(len(n_set)):
    row = []
    for y in range(len(p_set)):
        row.append((None, None, None))
    table.append(row)

# For each n.
for row, n in enumerate(sorted(n_set)):
    # For each p.
    for col, p in enumerate(sorted(p_set)):
        # Find q = 0 data.
        subset_q0 = [r for r in data if r['n'] == n and r['p'] == p and r['q'] == 0]

        # Find optimal b.
        best_q0 = min(subset_q0, key=lambda r:r['time'])

        # Find q > 0 data.
        subset_qpos = [r for r in data if r['n'] == n and r['p'] == p and r['q'] > 0]

        # Find optimal q and b.
        best_qpos = min(subset_qpos, key=lambda r:r['time'])

        # Compute speedup.
        numerator   = best_q0['time']
        denominator = best_qpos['time']
        speedup     = numerator / denominator

        # Store in table.
        table[row][col] = (best_q0, best_qpos, speedup)

# Print table.
num_cols = len(p_set)
print('        | ', end='')
for col, p in enumerate(sorted(p_set)):
    print('             p={0:2d} | '.format(p), end='')
print()
print('--------+', end='')
for x in range(len(p_set)):
    print('-------------------+', end='')
print()
for row, n in enumerate(sorted(n_set)):
    print('n={0:5d} | '.format(n), end='')
    line = []
    for col, p in enumerate(sorted(p_set)):
        best_q0, best_qpos, speedup = table[row][col]
        b0   = best_q0['b']
        bpos = best_qpos['b']
        qpos = best_qpos['q']
        line.append('{0:5.3f} ({1:3d}/{2:3d}:{3:1d})'.format(speedup, b0, bpos, qpos))
    print(' | '.join(line) + ' |')


